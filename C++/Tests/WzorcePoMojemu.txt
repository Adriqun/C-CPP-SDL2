Wzorce kreacyjne:

	Fabryka abstrakcyjna - 

	Budowniczy - 

	Metoda wytwórcza - kreacyjny wzorzec projektowy, którego celem jest dostarczenie interfejsu do tworzenia obiektów nieokreślonych jako powiązanych typów[1]. Tworzeniem egzemplarzy zajmują się podklasy. Rozpatrzmy aplikację, której funkcjonalność może być rozszerzana za pomocą wtyczek. Może to być przeglądarka plików graficznych. Mnogość formatów graficznych sprawia, że jest prawie niemożliwym zaimplementowanie ich wszystkich naraz. Potrzebne więc jest uniwersalne rozwiązanie – takim rozwiązaniem jest system wtyczek do zapisywania i odczytywania plików graficznych. Metoda wytwórcza zwraca wskaźnik do obiektu klasy, który może manipulować obrazami danego formatu. Dzięki takiemu rozwiązaniu bezproblemowo możemy rozszerzać listę obsługiwanych formatów. 

	Prototyp - kreacyjny wzorzec projektowy, którego celem jest umożliwienie tworzenia obiektów danej klasy bądź klas z wykorzystaniem już istniejącego obiektu, zwanego prototypem. Głównym celem tego wzorca jest uniezależnienie systemu od sposobu w jaki tworzone są w nim produkty. Prototyp kopiuje anijeżeli tworzy nowe obiekty.

	Singleton - kreacyjny wzorzec projektowy, którego celem jest ograniczenie możliwości tworzenia obiektów danej klasy do jednej instancji oraz zapewnienie globalnego dostępu do stworzonego obiektu. Niekiedy wzorzec uogólnia się do przypadku wprowadzenia pewnej maksymalnej liczby obiektów, jakie mogą istnieć w systemie. Omawiany wzorzec stosujemy między innymi wtedy, gdy nie chcemy tworzyć w budowanej aplikacji podklas obiektu budującego (jak to jest w przypadku wzorca fabryki abstrakcyjnej). Wzorzec ten stosujemy podczas stosowania klas specyfikowanych podczas działania aplikacji.

Wzorce strukturalne:
	Adapter - strukturalny wzorzec projektowy, którego celem jest umożliwienie współpracy dwóm klasom o niekompatybilnych interfejsach. Adapter przekształca interfejs jednej z klas na interfejs drugiej klasy. Innym zadaniem omawianego wzorca jest opakowanie istniejącego interfejsu w nowy. Istnieje również adaptera dwukierunkowy, którego zadaniem jest adaptowanie interfejsów klienta oraz adaptowanego. Dzięki takiemu rozwiązaniu każda z klas może pełnić zarówno funkcję klienta jak i adaptowanego.

	Most - strukturalny wzorzec projektowy, który pozwala oddzielić abstrakcję obiektu od jego implementacji (interfejs zostaje całkowicie odizolowany od swojej implementacji). Dla przykładu posiadamy klase abstrakcyjną RysujAPI, która posiada funkcje wirtualne RysujOkrag() oraz RysujKwadrat(). Posiadamy również dwie klasy pochodne OpenGL oraz DirectX, każda z tych klas posiada implementacje wspomnianych funkcji. Ostatnią klasą jest Ksztalt. Konstruktor tej klasy posiada parametr RysujApi*, w momencie tworzenia obiektu Ksztalt podajemy, którą implementację klasy RysujAPI chcemy.

	Kompozyt – strukturalny wzorzec projektowy, którego celem jest składanie obiektów w taki sposób, aby klient widział wiele z nich jako pojedynczy obiekt. Wzorzec ten stosuje się, gdy wygodniej jest korzystać z pewnych operacji dla danego obiektu w ten sam sposób jak dla grupy obiektów, np. rysując na ekranie prymitywy lub obiekty złożone z prymitywów; zmieniając rozmiar zarówno pojedynczych prymitywów jak i obiektów złożonych z prymitywów (z zachowaniem proporcji).

	Dekorator - wzorzec projektowy należący do grupy wzorców strukturalnych. Pozwala na dodanie nowej funkcji do istniejących klas dynamicznie podczas działania programu. Wzorzec dekoratora polega na opakowaniu oryginalnej klasy w nową klasę "dekorującą". Zwykle przekazuje się oryginalny obiekt jako parametr konstruktora dekoratora, metody dekoratora wywołują metody oryginalnego obiektu i dodatkowo implementują nową funkcję. Dekoratory są alternatywą dla dziedziczenia. Dziedziczenie rozszerza zachowanie klasy w trakcie kompilacji, w przeciwieństwie do dekoratorów, które rozszerzają klasy w czasie działania programu. Rozważmy okno w graficznym interfejsie użytkownika. By pozwolić na przewijanie jego zawartości, należy dodać do niego poziome lub pionowe paski przewijania. Okna są reprezentowane przez instancję klasy Okno i klasa ta nie powinna posiadać żadnych metod dodających paski przewijania. Można utworzyć podklasę PrzewijaneOkno, która udostępniałaby te metody lub stworzyć OknoDekoratorPrzewijane, który jedynie dodawałby tę funkcję do istniejących obiektów Okno. W tym miejscu działałyby oba rozwiązania. Teraz załóżmy, że potrzeba dodać ramki dookoła okien. I w tym przypadku klasa Okno nie ma takiej funkcji. Pojawia się problem z podklasą PrzewijaneOkno, bo aby dodać ramki do wszystkich okien potrzeba stworzyć podklasy OknoZRamką i OknoPrzewijaneZRamką. Problem staje się jeszcze większy z każdą kolejną opcją. W przypadku dekoratorów wystarczy stworzyć jedną klasę OknoDekoratorRamka - podczas działania programu można dynamicznie dekorować istniejące okna z OknoDekoratorPrzewijane lub OknoDekoratorRamka lub oboma.

	Fasada - wzorzec projektowy należący do grupy wzorców strukturalnych. Służy do ujednolicenia dostępu do złożonego systemu poprzez wystawienie uproszczonego, uporządkowanego interfejsu programistycznego, który ułatwia jego użycie. Przykładem użycia wzorca fasady może być aplikacja bankomatowa, która musi wchodzić w interakcję z systemem bankowym. Skoro aplikacja bankomatowa wykorzystuje tylko niewielką część możliwości systemu bankowego (autoryzacja karty, sprawdzenie stanu konta, wypłata i ew. wpłata), to można zastosować obiekt fasady, który zasłoni przed zewnętrznymi aplikacjami skomplikowaną strukturę wewnętrzną systemu bankowego. Upraszcza to pisanie aplikacji na bankomaty, a jednocześnie zapewnia lepsze bezpieczeństwo systemu bankowego. (Klient komunikuje się z systemem poprzez fasadę, która w jego imieniu wykonuje niezbędne operacje na złożonym systemie. To, czy klient posiada także bezpośredni dostęp do systemu, leży w gestii programisty implementującego wzorzec, ponieważ możliwe jest wykorzystanie go do podziału systemu na warstwy, gdzie fasady służą do uproszczenia i ujednolicenia komunikacji.)

	Pyłek - strukturalny wzorzec projektowy, którego celem jest zmniejszenie wykorzystania pamięci poprzez poprawę efektywności obsługi dużych obiektów zbudowanych z wielu mniejszych elementów poprzez współdzielenie wspólnych małych elementów. Wzorzec Pyłek stosuje się tam, gdzie jedna klasa ma wiele egzemplarzy, a każdy z tych egzemplarzy może być sterowany w ten sam sposób. Przykładowo tenże wzorzec można zastosować w programie wspomagającym modelowanie przestrzenne terenu. Jednym z wielu elementów, które muszą się w nim znaleźć są obiekt reprezentujący drzewo. Zakładamy, że obiekt taki posiada informacje o wyglądzie drzewa oraz jakieś inne jego cechy, przy czym także jego wysokości oraz jego współrzędne położenia. Podczas modelowania wielkich kompleksów zieleni złożonych z wielu egzemplarzy drzewa program może zacząć działać niezadowalająco wolno. Aby uporać się z takim problemem można zastosować wzorzec Pyłek. Po zastosowaniu tego wzorca projektowego zamiast tworzyć indywidualny egzemplarz klasy (obiekt) dla każdego drzewa możliwe jest stworzenie kompleksowego obiektu, który będzie w sobie zawierał informacje o wszystkich drzewach renderowanych na modelowanym terenie.

	Pełnomocnik - strukturalny wzorzec projektowy Proxy, jego zadaniem jest zbudowanie klasy, która zastępuje/emuluje zachowanie innego klasy/obiektu Jest to jeden z najprostszych wzorców projektowych, bardzo często niepozornie siedzący w kodzie. Cecy to: kontrola dostępu do ochranianego obiektu – np. dostęp do danych po autoryzacji użytkownika, opóźnienie tworzenia kosztownego obiektu, obiekt jest tworzony kiedy to jest niezbędne – tworzenie na żądanie, cachowanie pewnych danych obiektu – niektóre dane klasy długo się generują, albo są przeliczane wcześniej. Przykładowa implementacja to klasa, która dostarcza wygenerowane obrazy, przy pierwszym wywołaniu dostarczone są tylko grafiki poglądowe - generowanie właściwych wymaga bardzo dużo mocy obliczeniowej.

Wzorce czynnościowe:
	Łańcuch zobowiązań - jest czynnościowym wzorcem projektowym, który pozwala na oddzielenie nadawcy żądania od obiektu, który je zrealizuje. Osiąga to poprzez utworzenie łańcucha z obiektów, potencjalnie mogących obsłużyć żądanie. Sztandarowym przykładem jest obsługa funkcji pomocy w programie okienkowym. Każdy widget może mieć swój własny sposób na obsługiwanie zapytania o pomoc albo też w ogóle nie zapewniać takiej funkcji. W tym wypadku to jego rodzic powinien spróbować obsłużyć żądanie lub przekazać je dalej, jeżeli nie potrafi tego zrobić. To właśnie tworzy łańcuch i znacznie upraszcza połączenia między obiektem, który wysyła żądanie, a odbiorcami.

	Polecenie - należy do grupy czynnościowych wzorców projektowych, czyli opisujących sposób przepływu danych. Celem tego wzorca jest enkapsulacja żądań/czynności użytkownika (wraz z ich parametrami) do osobnych obiektów, tzw. poleceń, pozwala także na korzystanie z tzw. poleceń odwracalnych. Wzorzec znajduje zastosowanie wszędzie tam, gdzie musimy zapamiętywać wykonywane operacje lub je wycofywać. Mogą to być zarówno przedstawione wyżej programy okienkowe z opcją cofania, jak i np. systemy obsługi transakcji w instalatorach lub bazach danych i mechanizmy nagrywania makr. Drugim obszarem zastosowań są sytuacje, gdy identyczne polecenia muszą być parametryzowane różnymi danymi w zależności od tego, kto odpowiada za ich obsłużenie. Wzorzec Polecenie znalazł też zastosowanie w implementacjach mechanizmów zdalnego wykonywania procedur, gdzie obiekty żądań są serializowane i przesyłane jako strumień bajtów do innego komputera, który odpowiada za ich wykonanie.

	Interpreter - czynnościowy wzorzec projektowy, którego celem jest zdefiniowanie opisu gramatyki pewnego języka interpretowalnego, a także stworzenie dla niej interpretera, dzięki któremu będzie możliwe rozwiązanie opisanego problemu. Omawiany wzorzec projektowy można wykorzystać w sytuacjach, gdy zdania, zapisane w pewnym interpretowalnym języku, mogą być reprezentowane jako drzewa składniowe oraz istnieje prosta gramatyka opisująca ten język. Do przykładowych zastosowań tego wzorca należy interpretacja rzymskiego systemu liczbowego.

	Iterator – czynnościowy wzorzec projektowy (obiektowy), którego celem jest zapewnienie sekwencyjnego dostępu do podobiektów zgrupowanych w większym obiekcie bez ujawniania reprezentacji wewnętrznej tych obiektów.

	Obserwator - wzorzec projektowy należący do grupy wzorców czynnościowych. Używany jest do powiadamiania zainteresowane obiekty o zmianie stanu pewnego innego obiektu. W programowaniu obiektowym obiekty posiadają pewien stan, tj. zbiór aktualnych wartości pól obiektu, który w wyniku wykonywania na nich operacji może ulegać zmianie. Od bieżącego stanu mogą być zależne inne obiekty, dlatego musi istnieć możliwość ich powiadomienia o jego zmianie tak, aby mogły one się do niej dostosować. Możemy także żądać, aby inne obiekty były powiadamiane o tym, że inny obiekt próbuje wykonać konkretną czynność, np. ponownie nawiązywać utracone połączenie z bazą danych. Pragniemy zaimplementować ogólny mechanizm, który umożliwi nam osiągnięcie tych celów. We wzorcu obserwator wyróżniamy dwa podstawowe typy obiektów: obserwowany oraz obserwujący.

	Mediator - czynnościowy wzorzec projektowy, który jako jedyny zna większość współpracujących ze sobą obiektów. Mediator zapewnia zmniejszenie ilości powiązań pomiędzy klasami, będąc jedyną klasą, która dokładnie zna metody wszystkich innych klas, którymi zarządza. Nie muszą one nic o sobie wiedzieć, jedynie przekazują polecenia mediatorowi, a ten rozsyła je do odpowiednich obiektów. Mediator jest podobny w działaniu do wzorca obserwatora, lecz występują różnice: obserwator zna wszystkie obiekty do których jest wysyłany komunikat, mediator – hermetyzuje te połączenia, obiekt nadający zna tylko mediatora, żadnego innego obiektu.

	Pamiątka - czynnościowy wzorzec projektowy. Jego zadaniem jest zapamiętanie i udostępnienie na zewnątrz wewnętrznego stanu obiektu bez naruszania hermetyzacji. Umożliwia to przywracanie zapamiętanego stanu obiektu. Pamiątka może zostać wykorzystana w procesorze tekstu do zaimplementowania operacji "Cofnij" oraz "Ponów". Za każdym razem kiedy użytkownik wykonuje jakąś akcję – wprowadza tekst, zmienia wielkość czcionki czy jej kolor – tworzony jest obiekt pamiątki zapamiętujący bieżący stan dokumentu. Gdy użytkownik zleci wycofanie ostatniej operacji, stan dokumentu zostanie odtworzony za pomocą wcześniej zapisanej pamiątki. Inny przykład zastosowania tego wzorca projektowego to ziarno generatora liczb pseudolosowych czy pojedynczy stan automatu skończonego.

	Stan - czynnościowy wzorzec projektowy, który umożliwia zmianę zachowania obiektu poprzez zmianę jego stanu wewnętrznego. Innymi słowy - uzależnia sposób działania obiektu od stanu w jakim się aktualnie znajduje. Rozważmy aplikację, której zadaniem jest rysowanie różnych obiektów za pomocą różnych komponentów. Aplikacja taka może posiadać abstrakcyjny interfejs reprezentujący narzędzie do rysowania implementowany przez klasy konkretnych narzędzi. Klasa główna będzie wywoływać odpowiednie narzędzie do rysowania - w zależności od tego w jakim będzie stanie. Innym przykładem są gry komputerowe,  klasa nadrzędna posiada stan w jakim aktualnie znajduje się gra tj. "menu", "rozgrywka", "opcje" itd.

	Strategia - czynnościowy wzorzec projektowy, który definiuje rodzinę wymiennych algorytmów i kapsułkuje je w postaci klas. Umożliwia wymienne stosowanie każdego z nich w trakcie działania aplikacji niezależnie od korzystających z nich użytkowników. Rozważmy program generujący statystyki dotyczące podanego na wejściu kodu źródłowego takie, jak liczba wierszy, liczba klas itd. W mechanizmie generowania statystyk możemy wyróżnić część kodu specyficzną dla języka programowania, w którym napisany został kod oraz ogólną, niezależną od języka. Chcielibyśmy, aby nasz program był uniwersalny i obsługiwał wiele języków programowania, a także by w przyszłości istniała możliwość dodawania nowych.Rozwiązaniem jest zastosowanie wzorca Strategia, gdzie algorytmy specyficzne dla języków programowania wydzielimy jako osobne klasy ze wspólnym interfejsem, który umożliwi programowi wyciąganie określonych informacji o kodzie źródłowym.

	Metoda szablonowa - czynnościowy wzorzec projektowy. Jego zadaniem jest zdefiniowanie metody, będącej szkieletem algorytmu. Algorytm ten może być następnie dokładnie definiowany w klasach pochodnych. Niezmienna część algorytmu zostaje opisana w metodzie szablonowej, której klient nie może nadpisać. W metodzie szablonowej wywoływane są inne metody, reprezentujące zmienne kroki algorytmu. Mogą one być abstrakcyjne lub definiować domyślne zachowania. Klient, który chce skorzystać z algorytmu, może wykorzystać domyślną implementację bądź może utworzyć klasę pochodną i nadpisać metody opisujące zmienne fragmenty algorytmu. Najczęściej metoda szablonowa ma widoczność publiczną, natomiast metody do przesłonięcia mają widoczność chronioną lub prywatną, tak, aby klient nie mógł ich użyć bezpośrednio. Przykładem zastosowania tego wzorca są biblioteki, wspomagające automatyzację testów jednostkowych. Biblioteka jUnit definiuje ogólny algorytm wykonywania testów. Składa się on z trzech podstawowych kroków: przygotowania środowiska do wykonania testów, wykonania testów, a następnie posprzątania po wykonanych testach. Kroki te reprezentowane są przez metody setUp, runTest oraz tearDown. Wymienione metody wykonywane są w niezmiennej kolejności przez metodę run, której klient nie może zmienić. Dzięki temu, użytkownik nie może zmieniać kolejności podstawowych bloków algorytmu, może jednak nadpisać metody setUp, runTest oraz tearDown, co pozwala mu dostosować testy do swoich potrzeb.

	Odwiedzający - wzorzec czynnościowy, którego zadaniem jest odseparowanie algorytmu od struktury obiektowej na której operuje. Praktycznym rezultatem tego odseparowania jest możliwość dodawania nowych operacji do aktualnych struktur obiektów bez konieczności ich modyfikacji. Idea wzorca polega na stworzeniu interfejsu odwiedzającego (Visitor) zawierającego metody wirtualne Visit dla każdej z implementacji elementów (dziedziczących po klasie Element) w zadanej strukturze obiektów. Wzorzec wizytatora może być zastosowany przy implementacji drzewa wyprowadzenia w parserach lub kompilatorach. Wzorzec odwiedzający jest innym podejściem do problemu w stosunku do wzorca strategia. Wzorzec strategia skupia się na jednej klasie po której dziedziczą inne klasy zawierające algorytmy (stosunek 1 do wielu). Natomiast wzorzec odwiedzający skupia się na jednej klasie po której dziedziczą inne klasy jednak same te klasy zawierają w sobie również funkcje do obsługi innych klas pochodnych (stosunek wielu do wielu).